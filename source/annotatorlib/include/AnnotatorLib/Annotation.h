// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#ifndef ANNOTATOR_ANNOTATORLIB_ANNOTATION_H
#define ANNOTATOR_ANNOTATORLIB_ANNOTATION_H

/************************************************************
 Annotation class header
 ************************************************************/
#include <vector>

#include <AnnotatorLib/AnnotatorLibDatastructs.h>
#include <AnnotatorLib/annotatorlib_api.h>

namespace AnnotatorLib {

class Attribute;
class Frame;
class Object;

/************************************************************/
/**
 * @brief The Annotation class
 * Represents a label for an object on a specific frame.
 */
class ANNOTATORLIB_API Annotation {

  friend class Object;

public:

  /////////CONSTANTS/////////////

  const unsigned long id = 0;
  const AnnotationType type;

  ////////CONSTRUCTORS//////////

  Annotation() = delete;
  Annotation(unsigned long id, Frame* frame, Object* obj, AnnotationType type = AnnotationType::RECTANGLE);
  Annotation(Frame* frame, Object* obj, AnnotationType type);
  Annotation(const Annotation &obj);

  /////////////////////////

  /**
   * @brief operator >: comparing is based on frame-number
   * @param left
   * @param right
   * @return
   */
  bool operator> (const Annotation & right);
  bool operator>= (const Annotation & right);
  bool operator< (const Annotation & right);
  bool operator<= (const Annotation & right);
  bool operator== (const Annotation & right);
  bool operator!= (const Annotation & right);


  ////////METHODS//////////

  /**
   *
   * @return id
   */
  static unsigned long genId();

  unsigned long getId() const;

  std::vector<Attribute *> getAttributes() const;
  bool addAttribute(Attribute *attribute);
  bool removeAttribute(Attribute *attribute);
  Frame *getFrame() const;
  Object *getObject() const;
  AnnotationType getType() const;
  /**
   * @brief Set this annotation to visible and
   * register/unregister to its associated object and frame.
   * @param vis
   * @param autoreg [default = false]
   */
  void setVisible(bool vis);
  /**
   * @brief Retrun if the annotation is visible and
   * registered to its object and frame.
   * @return
   */
  bool isVisible() const;


  /**
   * @brief setPosition
   * @param x
   * @param y
   */
  void setPosition(float x, float y);

  void setPosition(float x, float y, float width, float height);
  /**
   * @brief setPosition
   * @param x
   * @param y
   * @param hradius the radius horizontally
   * @param vradius the radius vertically
   */
  void setCenterPosition(float x, float y, float hradius, float vradius);

  int getX() const;
  void setX(float x);
  int getY() const;
  void setY(float y);

  float getWidth() const;
  void setWidth(float width);
  float getHeight() const;
  void setHeight(float height);

  float getHRadius() const;
  void setHRadius(float hradius);
  float getVRadius() const;
  void setVRadius(float vradius);

  Annotation *getNext() const;
  Annotation *getPrevious() const;
  void setPrevious(Annotation *previous);
  void setNext(Annotation *next);

  Annotation *getFirst();
  Annotation *getLast();
  bool isLast() const;
  bool isFirst() const;

  void setFinished(bool ended);

  /**
   * @brief isFinished
   * Returns if annotation is last annotation of track.
   * @return
   */
  bool isFinished();

  void setInterpolated(bool interpolated);
  bool isInterpolated() const;

protected:

  std::vector<Attribute *> attributes;

  Annotation *next = nullptr;
  Annotation *previous = nullptr;

  // top, left corner, width, height
  float x = 0;
  float y = 0;

  float width = 0;
  float height = 0;

  bool interpolated = false;
  bool visible;

private:
  /**
   * @brief Register annotation to its object and frame.
   * @param vis
   */
  void registerAnnotation();
  void unregisterAnnotation();

  ///////////////////////////////

  Frame *frame = nullptr;
  Object *object = nullptr;

  bool is_registered;

};
/************************************************************/
/* External declarations (package visibility)               */
/************************************************************/

/* Inline functions                                         */

}  // of namespace AnnotatorLib

/************************************************************
 End of Annotation class header
 ************************************************************/

#endif
