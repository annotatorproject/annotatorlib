// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#ifndef ANNOTATOR_ANNOTATORLIB_SESSION_H
#define ANNOTATOR_ANNOTATORLIB_SESSION_H

/************************************************************
 Session class header
 ************************************************************/
#include <vector>
#include <unordered_map>
#include <memory> //smart pointer
#include <AnnotatorLib/AnnotatorLibDatastructs.h>
#include <AnnotatorLib/annotatorlib_api.h>
#include <AnnotatorLib/Annotation.h>
#include <AnnotatorLib/AnnotatorAlgoInterface.h>
#include <AnnotatorLib/Attribute.h>
#include <AnnotatorLib/Class.h>
#include <AnnotatorLib/Commands/Command.h>
#include <AnnotatorLib/Frame.h>
#include <AnnotatorLib/Object.h>

using std::shared_ptr;
using std::unordered_map;

namespace AnnotatorLib {

/************************************************************/
/**
 * @brief The Session class
 * Contains pointers to all data within a session.
 */
class ANNOTATORLIB_API Session {
 public:
  Session();
  virtual ~Session();

  virtual void clearAll();

  // Attributes
  virtual std::unordered_map<unsigned long, std::shared_ptr<Attribute>> const& getAttributes() const { return attributes;}
  /**
   * @brief Add an attribute to the session.
   * @param c
   * @return
   */
  virtual bool addAttribute(const shared_ptr<Attribute> attribute);
  virtual shared_ptr<Attribute> removeAttribute(Attribute *attribute);
  virtual shared_ptr<Attribute> getAttribute(unsigned long id) const;

  // Annotations

//  virtual std::pair<std::unordered_map<unsigned long, std::shared_ptr<Annotation>>::const_iterator,
//  std::unordered_map<unsigned long, std::shared_ptr<Annotation>>::const_iterator> getAnnotationsIterator() const;

  virtual std::unordered_map<unsigned long, std::shared_ptr<Annotation>> const& getAnnotations() const { return annotations;}

  /**
   * @brief Will add the given annotation, the associated object
   * and frame to this session. Checks for duplicates.
   * @param annotation
   * @return
   */
  virtual bool addAnnotation(shared_ptr<Annotation> annotation, bool add_associated_objects = true);
  virtual shared_ptr<Annotation> removeAnnotation(unsigned long id, bool unregister = true);
  virtual shared_ptr<Annotation> getAnnotation(unsigned long id) const;
  virtual shared_ptr<Annotation> getAnnotation(const shared_ptr<Frame>, const shared_ptr<Object>) const;

  // Classes
  virtual std::unordered_map<std::string, std::shared_ptr<Class>> const& getClasses() const { return classes; }

  /**
   * @brief Add a class to the session.
   * @param c
   * @return
   */
  virtual bool addClass(shared_ptr<Class> c);
  virtual shared_ptr<Class> removeClass(Class *c);
  /**
   * Get class by name.
   * complexity: O(1)
   * @brief getClass
   * @param name
   * @return
   */
  virtual shared_ptr<Class> getClass(std::string name) const;
  /**
   * Deprecated! Use getClass(string name) instead!
   * complexity: O(N)
   * @brief Session::getClass
   * @param id
   * @return
   */
  virtual shared_ptr<Class> getClass(unsigned long id) const;

  // Frames
  virtual std::unordered_map<unsigned long, std::shared_ptr<Frame>> const& getFrames() const { return frames; }

  /**
   * @brief Will add the given frame and all annotations, objects
   * within this frame to this session. Checks for duplicates.
   * @param frame
   * @return
   */
  virtual bool addFrame(shared_ptr<Frame> frame, bool add_associated_objects = true);
  virtual shared_ptr<Frame> removeFrame(unsigned long frame_nmb, bool remove_annotations = true);
  /**
   * @brief getFrame by given number.
   * If it does not exist we create it.
   * @param number
   * @return The Frame by given Frame Number
   */
  virtual shared_ptr<Frame> getFrame(unsigned long number);

  /**
   * @brief Will add the given object and all associated annotations, plus
   * frames
   * to this session. Checks for duplicates.
   * @param object
   * @return
   */
  virtual bool addObject(shared_ptr<Object> object, bool add_associated_objects = true);
  virtual shared_ptr<Object> removeObject(unsigned long id, bool remove_annotations = true);
  virtual shared_ptr<Object> getObject(unsigned long id) const;
  virtual std::unordered_map<unsigned long, std::shared_ptr<Object>> const& getObjects() const { return objects; }

  /**
   * Executes the command and manages all involved memory.
   * @brief execute
   * @param command
   * @return
   */
  virtual bool execute(shared_ptr<AnnotatorLib::Commands::Command> command);
  virtual bool redo();
  virtual bool undo();

 private:
  std::unordered_map<unsigned long, std::shared_ptr<Frame>> frames;
  std::unordered_map<unsigned long, std::shared_ptr<Object>> objects;
  std::unordered_map<unsigned long, std::shared_ptr<Attribute>> attributes;
  std::unordered_map<unsigned long, std::shared_ptr<Annotation>> annotations;
  std::unordered_map<std::string, std::shared_ptr<Class>> classes;

  unsigned int commandIndex = 0;
  std::vector<std::shared_ptr<AnnotatorLib::Commands::Command>> commands;

  AnnotatorAlgo::AnnotatorAlgoInterface *annotatorAlgo;
};
/************************************************************/
/* External declarations (package visibility)               */
/************************************************************/

/* Inline functions                                         */

}  // of namespace AnnotatorLib

/************************************************************
 End of Session class header
 ************************************************************/

#endif
