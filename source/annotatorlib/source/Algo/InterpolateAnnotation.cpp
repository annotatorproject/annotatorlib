// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#define Annotator_AnnotatorLib_Algo_InterpolateAnnotation_BODY

/************************************************************
 Annotation class body
 ************************************************************/

// include associated header file
#include "AnnotatorLib/Algo/InterpolateAnnotation.h"
#include <assert.h>
#include <algorithm>
#include "AnnotatorLib/Annotation.h"
#include "AnnotatorLib/Frame.h"
#include "AnnotatorLib/Session.h"

namespace AnnotatorLib {
namespace Algo {

Annotation *InterpolateAnnotation::getInterpolation(Frame *frame,
                                                    Annotation *start,
                                                    Annotation *end) {
  if (start == nullptr) return nullptr;

  Annotation *annotation = new Annotation(frame, start->getObject(), start->getType());
  annotation->setPrevious(start);

  if (end == nullptr) return annotation;

  unsigned long startFrame = start->getFrame()->getFrameNumber();
  unsigned long endFrame = end->getFrame()->getFrameNumber();
  unsigned long curFrame = frame->getFrameNumber();

  assert(startFrame < endFrame);
  assert(startFrame < curFrame);

  float multiplier = 1.0f * (curFrame - startFrame) / (endFrame - startFrame);

  float curX = start->getX() + (end->getX() - start->getX()) * multiplier;
  float curY = start->getY() + (end->getY() - start->getY()) * multiplier;

  annotation->setX(curX);
  annotation->setY(curY);

  float curWidth =
      start->getWidth() + (end->getWidth() - start->getWidth()) * multiplier;
  float curHeight =
      start->getHeight() + (end->getHeight() - start->getHeight()) * multiplier;

  annotation->setWidth(curWidth);
  annotation->setHeight(curHeight);

  annotation->setNext(end);

  return annotation;
}

Annotation *InterpolateAnnotation::getInterpolation(Frame *frame,
                                                    Object *object,
                                                    bool interpolationsOnly) {
  std::vector<Annotation *> annotations =
      getInterpolations(frame, object->getAnnotations(), interpolationsOnly);
  if (annotations.size() > 0) return annotations[0];
  return nullptr;
}

std::vector<Annotation *> InterpolateAnnotation::getInterpolations(
    Frame *frame, const Session *session, bool interpolationsOnly) {
  return getInterpolations(frame, session->getAnnotations(),
                           interpolationsOnly);
}

std::vector<Annotation *> InterpolateAnnotation::getInterpolations(
    Frame *frame, const std::vector<Annotation *> annotations,
    bool interpolationsOnly) {
  std::vector<Annotation *> return_annotations;

  for (Annotation *a : annotations) {
    // Is Annotation before actual frame?
    if (a->getFrame()->getFrameNumber() < frame->getFrameNumber()) {
      Annotation *annotation = nullptr;
      if (!a->isFinished() && a->isLast()) {
        annotation = new Annotation(frame, a->getObject(), a->getType());
        annotation->setPrevious(a);

        // Is next Annotation after actual frame? Then return interpolated
        // Annotation.
      } else if (a->getNext()->getFrame()->getFrameNumber() > frame->getFrameNumber()) {
        annotation = getInterpolation(frame, a, a->getNext());
      }

      if (annotation != nullptr) {
        annotation->setInterpolated(true);
        return_annotations.push_back(annotation);
      }
      // Is Annotation on actual frame?
    } else if (!interpolationsOnly &&
               a->getFrame()->getFrameNumber() == frame->getFrameNumber()) {
      return_annotations.push_back(a);
    } else {
    }
  }

  return return_annotations;
}

}  // of namespace Algo
}  // of namespace AnnotatorLib
