// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#define Annotator_AnnotatorLib_Algo_InterpolateAnnotation_BODY

/************************************************************
 InterpolateAnnotation class body
 ************************************************************/

// include associated header file
#include "AnnotatorLib/Algo/InterpolateAnnotation.h"
#include <assert.h>
#include <algorithm>
#include "AnnotatorLib/Annotation.h"
#include "AnnotatorLib/Frame.h"
#include "AnnotatorLib/Session.h"

namespace AnnotatorLib {
namespace Algo {

Annotation *InterpolateAnnotation::getInterpolation(Frame *frame,
                                                    Annotation *prev,
                                                    Annotation *next) {
  if (prev == nullptr) return nullptr;

  Annotation *annotation = new Annotation(prev, frame, true);

  if (next == nullptr) return annotation;

  unsigned long startFrame = prev->getFrame()->getFrameNumber();
  unsigned long endFrame = next->getFrame()->getFrameNumber();
  unsigned long curFrame = frame->getFrameNumber();

  assert(prev->getObject() == next->getObject());
  assert(startFrame < curFrame);
  assert(endFrame > curFrame);

  float multiplier = 1.0f * (curFrame - startFrame) / (endFrame - startFrame);

  float curX = prev->getX() + (next->getX() - prev->getX()) * multiplier;
  float curY = prev->getY() + (next->getY() - prev->getY()) * multiplier;

  annotation->setX(curX);
  annotation->setY(curY);

  float curWidth =
      prev->getWidth() + (next->getWidth() - prev->getWidth()) * multiplier;
  float curHeight =
      prev->getHeight() + (next->getHeight() - prev->getHeight()) * multiplier;

  annotation->setWidth(curWidth);
  annotation->setHeight(curHeight);

  return annotation;
}

Annotation *InterpolateAnnotation::getInterpolation(Frame *frame,
                                                    Object *object,
                                                    bool interpolationsOnly) {
  assert(frame);
  assert(object);
  // is it the first frame of the object?
  if (!interpolationsOnly && object->getAnnotations().size() == 1 &&
      *frame == *object->getLastAnnotation()->getFrame()) {
    return object->getLastAnnotation();
  }

  if (object->getAnnotations().size() > 1) {
    // is frame within the valid range of the object?
    if (*frame <= *object->getLastAnnotation()->getFrame() &&
        *frame >= *object->getFirstAnnotation()->getFrame()) {
      Annotation *a = object->getAnnotation(frame);

      if (a == nullptr) {
        // find the nearest neighbours (keyframes)
        Annotation *left = nullptr;
        Annotation *right = nullptr;
        object->findClosestKeyFrames(frame, left, right);
        return getInterpolation(frame, left, right);
      } else if (!interpolationsOnly) {
        return a;
      }
    }

  } else if (object->getLastAnnotation() &&
             *frame > *object->getLastAnnotation()->getFrame()) {
    // copy the previous annotation to the requested frame
    Annotation *annotation =
        new Annotation(object->getLastAnnotation(), frame, true);
    return annotation;
  }

  return nullptr;
}

std::vector<Annotation *> InterpolateAnnotation::getInterpolations(
    Frame *frame, const Session *session, bool interpolationsOnly) {
  return getInterpolations(frame, session->getObjects(), interpolationsOnly);
}

std::vector<Annotation *> InterpolateAnnotation::getInterpolations(
    Frame *frame, const std::vector<Object *> objects,
    bool interpolationsOnly) {
  std::vector<Annotation *> return_annotations;

  for (Object *o : objects) {
    Annotation *a = getInterpolation(frame, o, interpolationsOnly);

    if (a != nullptr) {
      return_annotations.push_back(a);
    }
  }

  return return_annotations;
}

}  // of namespace Algo
}  // of namespace AnnotatorLib
