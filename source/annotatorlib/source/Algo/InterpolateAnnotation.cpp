// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#define Annotator_AnnotatorLib_Algo_InterpolateAnnotation_BODY

/************************************************************
 Annotation class body
 ************************************************************/

// include associated header file
#include "AnnotatorLib/Algo/InterpolateAnnotation.h"
#include <assert.h>
#include <algorithm>
#include "AnnotatorLib/Annotation.h"
#include "AnnotatorLib/Frame.h"
#include "AnnotatorLib/Session.h"

namespace AnnotatorLib {
namespace Algo {

Annotation *InterpolateAnnotation::getInterpolation(Frame *frame,
                                                    Annotation *prev,
                                                    Annotation *next) {
  assert(prev->getNext() == next);
  assert(next->getPrevious() == prev);

  if (prev == nullptr) return nullptr;

  Annotation *annotation = new Annotation(frame, prev->getObject(), prev->getType());
  //annotation->setPrevious(prev); //NOTE: is now managed by Object

  if (next == nullptr) return annotation;

  unsigned long startFrame = prev->getFrame()->getFrameNumber();
  unsigned long endFrame = next->getFrame()->getFrameNumber();
  unsigned long curFrame = frame->getFrameNumber();

  assert(prev->getObject() == next->getObject());
  assert(startFrame < endFrame);
  assert(startFrame < curFrame);
  assert(endFrame > curFrame);

  float multiplier = 1.0f * (curFrame - startFrame) / (endFrame - startFrame);

  float curX = prev->getX() + (next->getX() - prev->getX()) * multiplier;
  float curY = prev->getY() + (next->getY() - prev->getY()) * multiplier;

  annotation->setX(curX);
  annotation->setY(curY);

  float curWidth =
      prev->getWidth() + (next->getWidth() - prev->getWidth()) * multiplier;
  float curHeight =
      prev->getHeight() + (next->getHeight() - prev->getHeight()) * multiplier;

  annotation->setWidth(curWidth);
  annotation->setHeight(curHeight);

  annotation->setNext(next);
  annotation->setInterpolated(true);

  return annotation;
}

Annotation *InterpolateAnnotation::getInterpolation(Frame *frame,
                                                    Object *object,
                                                    bool interpolationsOnly) {
//  std::vector<Annotation *> annotations =
//      getInterpolations(frame, object->getAnnotations(), interpolationsOnly);
//  //if (annotations.size() > 0) return annotations[0];

//  assert(annotations.size() == 1);


  //is frame with the valid range of the object?
  if (*frame <= *object->getLastAnnotation()->getFrame() && *frame >= *object->getFirstAnnotation()->getFrame()) {
    Annotation* a = object->getAnnotation(frame);
    if (a == nullptr) {
      //find the nearest neighbours (keyframes)
      Annotation* left = nullptr;
      Annotation* right = nullptr;
      object->findClosestKeyFrames(frame, left, right);
      return getInterpolation(frame, left, right);
    } else if (!interpolationsOnly){
      return a;
    }
  }

  return nullptr;
}

std::vector<Annotation *> InterpolateAnnotation::getInterpolations(
  Frame *frame, const Session *session, bool interpolationsOnly) {
  return getInterpolations(frame, session->getObjects(),
                         interpolationsOnly);
}

std::vector<Annotation *> InterpolateAnnotation::getInterpolations(
    Frame *frame, const std::vector<Object *> objects,
    bool interpolationsOnly) {

  std::vector<Annotation *> return_annotations;

  for (Object *o : objects) {

      Annotation* a = getInterpolation(frame, o, interpolationsOnly);

      if (a != nullptr)
        return_annotations.push_back(a);

//    // Is Annotation before actual frame?
//    if ( *a->getFrame() < *frame ) {
//      Annotation *annotation = nullptr;
//      if (!a->isFinished() && a->isLast()) {
//        annotation = new Annotation(frame, a->getObject(), a->getType());
//        //annotation->setPrevious(a); //NOTE: is now managed by Object

//        // Is next Annotation after actual frame? Then return interpolated
//        // Annotation.
//      } else if (*a->getNext()->getFrame() > *frame) {
//        annotation = getInterpolation(frame, a, a->getNext());
//      }

//      if (annotation != nullptr) {
//        annotation->setInterpolated(true);
//        return_annotations.push_back(annotation);
//      }
//      // Is Annotation on actual frame?
//    } else if (!interpolationsOnly &&
//               a->getFrame()->getFrameNumber() == frame->getFrameNumber()) {
//      return_annotations.push_back(a);
//    } else {
//    }

  }

  return return_annotations;
}

}  // of namespace Algo
}  // of namespace AnnotatorLib
