// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#define Annotator_AnnotatorLib_Annotation_BODY

/************************************************************
 Annotation class body
 ************************************************************/

// include associated header file
#include "AnnotatorLib/Annotation.h"
#include "AnnotatorLib/Frame.h"
#include "AnnotatorLib/Object.h"
#include <algorithm>

// Derived includes directives

namespace AnnotatorLib {

// static attributes (if any)
static long lastId = 100000;
/**
 *
 * @return id
 */
Annotation::Annotation() { this->id = genId(); }

Annotation::Annotation(const Annotation &obj) {
  this->id = genId();
  this->attributes = obj.attributes;
  this->next = obj.next;
  this->previous = obj.previous;

  this->type = obj.type;
  this->frame = obj.frame;
  this->object = obj.object;

  this->x = obj.x;
  this->y = obj.y;
  this->hradius = obj.hradius;
  this->vradius = obj.vradius;
}

Annotation::Annotation(AnnotationType type) {
  this->id = genId();
  this->type = type;
}

Annotation::Annotation(unsigned long id) {
  this->id = id;
  if (lastId < id)
    lastId = id;
}

unsigned long Annotation::genId() {
  lastId += 5;
  return lastId;
}

unsigned long Annotation::getId() { return id; }

std::vector<Attribute *> Annotation::getAttributes() { return attributes; }

bool Annotation::addAttribute(Attribute *attribute) {
  if (attribute != nullptr &&
      std::find(attributes.begin(), attributes.end(), attribute) ==
          attributes.end()) {
    attributes.push_back(attribute);
    return true;
  }
  return false;
}

bool Annotation::removeAttribute(Attribute *attribute) {
  std::vector<Attribute *>::const_iterator position =
      std::find(attributes.begin(), attributes.end(), attribute);
  if (position != attributes.end()) {
    attributes.erase(position);
    return true;
  }
  return false;
}

Frame *Annotation::getFrame() { return frame; }

void Annotation::setFrame(Frame *frame) {
  if (this->frame != frame) {
    this->frame = frame;
    // if(frame != nullptr)
    //    frame->addAnnotation(this);
  }
}

Object *Annotation::getObject() { return object; }

void Annotation::setObject(Object *object) {
  if (this->object != object) {
    this->object = object;
    if (object != nullptr)
      object->addAnnotation(this);
  }
}

AnnotationType Annotation::getType() { return this->type; }

void Annotation::setType(AnnotationType type) { this->type = type; }

void Annotation::setPosition(float x, float y, float hradius, float vradius) {
  this->x = x;
  this->y = y;
  this->hradius = hradius;
  this->vradius = vradius;
}

void Annotation::setPositionWH(float x, float y, int width, int height) {
  setPosition(x, y, width / 2, height / 2);
}

int Annotation::getX() { return x; }

void Annotation::setX(float x) { this->x = x; }

int Annotation::getY() { return y; }

void Annotation::setY(float y) { this->y = y; }

float Annotation::getHRadius() { return hradius; }

void Annotation::setHRadius(float hradius) { this->hradius = hradius; }

float Annotation::getVRadius() { return vradius; }

void Annotation::setVRadius(float vradius) { this->vradius = vradius; }

void Annotation::setNext(Annotation *next) {
  if (this->next != next) {
    if (next == nullptr) {
      // this->next->setPrevious(nullptr);
      this->next = next;
    } else {
      this->next = next;
      // next->setPrevious(this);
    }
  }
}

Annotation *Annotation::getNext() { return next; }

void Annotation::setPrevious(Annotation *previous) {
  if (this->previous != previous) {
    if (previous == nullptr) {
      // this->previous->setNext(nullptr);
      this->previous = previous;
    } else {
      this->previous = previous;
      // previous->setNext(this);
    }
  }
}

Annotation *Annotation::getPrevious() { return previous; }

Annotation *Annotation::getFirst() {
  if (this->previous == nullptr)
    return this;
  return previous->getFirst();
}

Annotation *Annotation::getLast() {
  if (this->isLast())
    return this;
  return next->getLast();
}

bool Annotation::isLast() {
  return this->next == nullptr || this->next == this;
}

bool Annotation::isFirst() { return this->previous == nullptr; }

void Annotation::setFinished(bool ended) {
  if (ended) {
    getLast()->next = getLast();
  } else {
    getLast()->next = nullptr;
  }
}

bool Annotation::isFinished() { return getLast()->next == getLast(); }

void Annotation::setInterpolated(bool interpolated) {
  this->interpolated = interpolated;
}

bool Annotation::isInterpolated() { return interpolated; }

void Annotation::setPosition(float x, float y) {
  this->x = x;
  this->y = y;
}

} // of namespace AnnotatorLib

/************************************************************
 End of Annotation class body
 ************************************************************/
