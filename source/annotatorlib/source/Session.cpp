// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#define Annotator_AnnotatorLib_Session_BODY

/************************************************************
 Session class body
 ************************************************************/

// include associated header file
#include <algorithm>
#include "AnnotatorLib/Session.h"

// Derived includes directives

namespace AnnotatorLib {

std::vector<Attribute *> Session::getAttributes()
{
    return attributes;
}

bool Session::addAttribute(Attribute *attribute)
{
    if (std::find(attributes.begin(), attributes.end(), attribute) == attributes.end()) {
        attributes.push_back(attribute);
        return true;
    }
    return false;
}

bool Session::removeAttribute(Attribute *attribute)
{
    std::vector<Attribute *>::const_iterator position = std::find(attributes.begin(), attributes.end(), attribute);
    if (position != attributes.end()){
        attributes.erase(position);
        return true;
    }
    return false;
}

Attribute *Session::getAttribute(unsigned long id) const
{
    for(Attribute * attribute: attributes)
    {
        if(attribute->getId() == id)
            return attribute;
    }
    return nullptr;
}

std::vector<Annotation *> Session::getAnnotations() const
{
    return annotations;
}

bool Session::addAnnotation(Annotation *annotation, Frame *frame)
{
    if (std::find(annotations.begin(), annotations.end(), annotation) == annotations.end()) {
        //TODO:
        //if( frame->addAnnotation(annotation)){
            frame->addAnnotation(annotation);
            annotations.push_back(annotation);
            return true;
        //}
    }
    return false;
}

bool Session::removeAnnotation(Annotation *annotation)
{
    std::vector<Annotation *>::iterator position = std::find(annotations.begin(), annotations.end(), annotation);
    if (position != annotations.end()){
        Frame *frame = annotation->getFrame();
        if (frame)
            frame->removeAnnotation(annotation);
        annotation->setVisible(false);
        annotations.erase(position);        
        return true;
    }
    return false;
}

Annotation *Session::getAnnotation(unsigned long id) const
{
    for(Annotation * annotation: annotations)
    {
        if(annotation->getId() == id)
            return annotation;
    }
    return nullptr;
}

std::vector<Class *> Session::getClasses()
{
    return classes;
}

bool Session::addClass(Class *c)
{
    if (std::find(classes.begin(), classes.end(), c) == classes.end()) {
        classes.push_back(c);
        return true;
    }
    return false;
}

bool Session::removeClass(Class *c)
{
    std::vector<Class *>::const_iterator position = std::find(classes.begin(), classes.end(), c);
    if (position != classes.end()){
        classes.erase(position);
        return true;
    }
    return false;
}

Class *Session::getClass(unsigned long id) const
{
    for(Class * c: classes)
    {
        if(c->getId() == id)
            return c;
    }
    return nullptr;
}

Class *Session::getClass(std::string name) const
{
    for(Class * c: classes)
    {
        if(c->getName() == name)
            return c;
    }
    return nullptr;
}

std::vector<Frame *> Session::getFrames()
{
    return frames;
}

bool Session::addFrame(Frame *frame)
{
    if (std::find(frames.begin(), frames.end(), frame) == frames.end()) {
        frames.push_back(frame);
        return true;
    }
    return false;
}

bool Session::removeFrame(Frame *frame)
{
    std::vector<Frame *>::const_iterator position = std::find(frames.begin(), frames.end(), frame);
    if (position != frames.end()){
        frames.erase(position);
        return true;
    }
    return false;
}

Frame *Session::getFrame(unsigned long number)
{
    for(Frame * frame: frames)
    {
        if(frame->getFrameNumber() == number)
            return frame;
    }
    Frame * frame = new Frame(number);
    addFrame(frame);
    return frame;
}

std::vector<Object *> Session::getObjects()
{
    return objects;
}

bool Session::addObject(Object *object)
{
    if (std::find(objects.begin(), objects.end(), object) == objects.end()) {
        objects.push_back(object);
        return true;
    }
    return false;
}

bool Session::removeObject(Object *object)
{
    std::vector<Object *>::const_iterator position = std::find(objects.begin(), objects.end(), object);
    if (position != objects.end()){
        objects.erase(position);
        return true;
    }
    return false;
}

Object *Session::getFirstObjectByName(std::string name)
{
    for(Object * object: objects)
    {
        if(object->getName() == name)
            return object;
    }
    return nullptr;
}

Object *Session::getObject(unsigned long id)
{
    for(Object * object: objects)
    {
        if(object->getId() == id)
            return object;
    }
    return nullptr;
}

bool Session::execute(Commands::Command *command)
{
    commands.erase(commands.begin() + commandIndex, commands.end());
    commands.push_back(command);
    commandIndex++;
    return command->execute();
}

bool Session::redo()
{
    if(commands.size() >= commandIndex){
        AnnotatorLib::Commands::Command *command = commands.at(commandIndex);
        commandIndex++;
        return command->execute();
    }
    return false;
}

bool Session::undo()
{
    commandIndex--;
    AnnotatorLib::Commands::Command *command = commands.at(commandIndex);
    return command->undo();
}

Session::Session()
{

}

Session::~Session()
{

}

// static attributes (if any)

}// of namespace AnnotatorLib

/************************************************************
 End of Session class body
 ************************************************************/
