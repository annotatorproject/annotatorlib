// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#define Annotator_AnnotatorLib_Session_BODY

/************************************************************
 Session class body
 ************************************************************/

// include associated header file
#include "AnnotatorLib/Session.h"
#include <algorithm>

namespace AnnotatorLib {

Session::Session() {}

Session::~Session() {
  // delete all
  this->annotations.clear();
  this->objects.clear();
  this->frames.clear();
  this->classes.clear();
  this->attributes.clear();
  this->commands.clear();
}

template<typename K, typename T>
T* find_raw_pointer( std::unordered_map< K, std::shared_ptr<T>> map, K key ) {
    auto got = map.find(key);
    if(got != map.end()) {
      return got->second.get();
    }
    return nullptr;
}

bool Session::addAttribute(Attribute *attribute) {
  Attribute* got = find_raw_pointer<unsigned long, Attribute>(attributes, attribute->getId());
  if(!got) {
    attributes.emplace(attribute->getId(), std::move(std::shared_ptr<Attribute>(attribute)));
    return true;
  }
  return false;
}

bool Session::removeAttribute(Attribute *attribute) {
  Attribute* got = find_raw_pointer<unsigned long, Attribute>(attributes, attribute->getId());
  if(got) {
    attributes.erase(attribute->getId());
    return true;
  }
  return false;
}

Attribute *Session::getAttribute(unsigned long id) const {
  return find_raw_pointer<unsigned long, Attribute>(attributes, id);
}

bool Session::addAnnotation(Annotation *annotation) {
  Annotation* got = find_raw_pointer<unsigned long, Annotation>(annotations, annotation->getId());
  if(!got) {
    annotation->registerAnnotation();
    annotations.insert(std::make_pair(annotation->getId(), std::shared_ptr<Annotation>(annotation)));
    return true;
  }
  return false;
}

bool Session::removeAnnotation(Annotation *annotation, bool unregister) {
  Annotation* got = find_raw_pointer<unsigned long, Annotation>(annotations, annotation->getId());
  if(got) {
    if (unregister) annotation->unregisterAnnotation();
    annotations.erase (annotation->getId());
    return true;
  }
  return false;
}

Annotation *Session::getAnnotation(unsigned long id) const {
  for (auto& pair : annotations) {
    if (pair.second->getId() == id) return pair.second.get();
  }
  return nullptr;
}

bool Session::addClass(Class *c) {
  Class* got = find_raw_pointer<std::string, Class>(classes, c->getName());
  if(!got) {
    classes.insert(std::make_pair(c->getName(), std::shared_ptr<Class>(c)));
    return true;
  }
  return false;
}

bool Session::removeClass(Class *c) {
  Class* got = find_raw_pointer<std::string, Class>(classes, c->getName());
  if(got) {
    classes.erase (c->getName());
    return true;
  }
  return false;
}

Class *Session::getClass(std::string name) const {
  Class* got = find_raw_pointer<std::string, Class>(classes, name);
  if(got) {
    return got;
  }
  return nullptr;
}

bool Session::addFrame(Frame *frame) {
  Frame* got = find_raw_pointer<unsigned long, Frame>(frames, frame->getId());
  if(!got) {
    frames.insert(std::make_pair(frame->getId(), std::shared_ptr<Frame>(frame)));
    return true;
  }
  return false;
}

bool Session::removeFrame(Frame *frame, bool remove_annotations) {
  Frame* got = find_raw_pointer<unsigned long, Frame>(frames, frame->getId());
  if(got) {
    if (remove_annotations) {
      for (Annotation *a : frame->getAnnotations()) {
        removeAnnotation(a, false);  // will remove annotations
      }
    }
    frames.erase (frame->getId());
    return true;
  }
  return false;
}

Frame *Session::getFrame(unsigned long number) {
  Frame* got = find_raw_pointer<unsigned long, Frame>(frames, number);
  if (got) return got;
  Frame* f = new Frame(number);
  addFrame(f);  //is this really a good idea?
  return f;
}

bool Session::addObject(Object *object) {
  Object* got = find_raw_pointer<unsigned long, Object>(objects, object->getId());
  if(!got) {
    if (object->hasAnnotations()) {
      for (Annotation *a : object->getAnnotations()) {
        addAnnotation(a);  // will add annotation, object and frame
      }
    }
    if (object->getClass()) addClass(object->getClass());
    objects.insert(std::make_pair(object->getId(), std::shared_ptr<Object>(object)));
    return true;
  }
  return false;
}

bool Session::removeObject(Object *object, bool remove_annotations) {
  Object* got = find_raw_pointer<unsigned long, Object>(objects, object->getId());
  if(got) {
    if (remove_annotations) {
      for (auto a : object->getAnnotations()) {
        removeAnnotation(a, false);  // will remove annotations
      }
    }
    objects.erase (object->getId());
    return true;
  }
  return false;
}

Object *Session::getObject(unsigned long id) const {
  return find_raw_pointer<unsigned long, Object>(objects, id);
}

//TODO: Data musst be managed in command.
bool Session::execute(Commands::Command *command) {
  commands.erase(commands.begin() + commandIndex, commands.end());
  commands.push_back(std::shared_ptr<Commands::Command>(command));
  commandIndex++;
  return command->execute();
}

bool Session::redo() {
  if (commands.size() >= commandIndex) {
    AnnotatorLib::Commands::Command *command = commands.at(commandIndex).get();
    commandIndex++;
    return command->execute();
  }
  return false;
}

bool Session::undo() {
  commandIndex--;
  AnnotatorLib::Commands::Command *command = commands.at(commandIndex).get();
  return command->undo();
}

// static attributes (if any)

}  // of namespace AnnotatorLib

/************************************************************
 End of Session class body
 ************************************************************/
